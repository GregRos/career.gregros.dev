> [!column|no-title]
> > [!success] Optimal complexity
> > Achieved by taking algorithms straight out of research papers.
> 
> > [!success] Ultra high performance
> > Extensively optimized against a massive suite of benchmarks and days of CPU profiling.
> 
> >[!success] Uniform API
>> Designed a uniform API spanning five collections and dozens of high-performance operations.
>
> > [!success] Minimal code duplication
> > Used abstractions and code generation to avoid having to write the same member twice.
> 
> > [!success] Invisible optimization
> > Controlled mutation and specialized algorithms for known input types allowed for even better performance.
>
> > [!success] Rigorous testing and benchmarks
> > Wrote my own framework to run thousands of integration tests and benchmarks.
> 
> > [!success] Error reporting
> > Wrote dozens of checks and descriptive error messages for common issues.
> 
> > [!success] Debugging features
> > Debugging attributes made the collections feel like first-class citizens in the framework.

